# GitLab CI/CD Pipeline for Flutter KeyCheck v3.0.0
# Comprehensive pipeline with multi-stage validation, performance testing, and optimization
# Reference: https://docs.gitlab.com/ee/ci/yaml/

# Base image with Dart SDK
image: dart:3.9.0

# Pipeline stages optimized for parallel execution
stages:
  - 🔍 analyze
  - 🧪 test
  - 🔑 validate-keys
  - 🏗️ build
  - ⚡ performance-test
  - 📊 report
  - 🚀 publish

# Global variables for optimization and consistency
variables:
  PUB_CACHE: "/opt/pub-cache"
  DART_TOOL_CACHE: ".dart_tool"
  FKC_CACHE_TTL_HOURS: "0"  # Deterministic cache for CI
  CI_MODE: "true"
  REPORTS_DIR: "reports"
  ARTIFACTS_DIR: "artifacts"
  # Performance settings
  DART_VM_OPTIONS: "--disable-dart-dev"
  # Resource limits
  MEMORY_LIMIT: "2GB"
  CPU_LIMIT: "2"

# Workflow rules - trigger on relevant changes only
workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - lib/**/*
        - bin/**/*
        - test/**/*
        - example/**/*
        - pubspec.yaml
        - .gitlab-ci.yml
        - .flutter_keycheck.yaml
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'
      when: never
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - lib/**/*
        - bin/**/*
        - test/**/*
        - example/**/*
        - pubspec.yaml
        - .gitlab-ci.yml
        - .flutter_keycheck.yaml
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+.*$/'
    - if: '$CI_PIPELINE_SOURCE == "schedule"'

# Multi-level caching strategy for maximum efficiency
cache:
  # Primary cache for dependencies
  - key:
      files:
        - pubspec.lock
    paths:
      - $PUB_CACHE/
      - $DART_TOOL_CACHE/
    policy: pull-push
  # Secondary cache for analysis results
  - key: analysis-$CI_COMMIT_SHA
    paths:
      - .dart_tool/flutter_keycheck/cache/
    policy: pull-push
  # Tertiary cache for build artifacts
  - key: build-artifacts-$CI_COMMIT_SHA
    paths:
      - build/
      - $ARTIFACTS_DIR/
    policy: pull-push

# Shared script definitions for reusability
.scripts:
  setup: &setup_script
    - echo "🚀 Setting up Dart environment"
    - dart --version
    - echo "📦 Installing dependencies"
    - dart pub get
    - mkdir -p $REPORTS_DIR $ARTIFACTS_DIR

  install_tool: &install_tool
    - echo "🔧 Installing flutter_keycheck CLI tool"
    - dart pub global activate --source path .
    - export PATH="$PATH:$PUB_CACHE/bin"
    - which flutter_keycheck
    - flutter_keycheck --version

  performance_setup: &performance_setup
    - echo "⚡ Setting up performance baseline"
    - mkdir -p performance/baseline performance/results
    - export FLUTTER_KEYCHECK_BENCHMARK=true

# Base job template for common configuration
.base_job:
  before_script:
    - *setup_script
  resource_group: ${CI_ENVIRONMENT_NAME}
  timeout: 10m
  interruptible: true

# Analysis stage - Code quality and static analysis
analyze:lint:
  extends: .base_job
  stage: 🔍 analyze
  script:
    - echo "🔍 Running Dart analyzer with strict mode"
    - dart analyze --fatal-infos --fatal-warnings --verbose > $REPORTS_DIR/dart_analyze.txt 2>&1
  artifacts:
    when: always
    paths:
      - $REPORTS_DIR/dart_analyze.txt
    reports:
      junit: $REPORTS_DIR/dart_analyze.txt
    expire_in: 7 days
  rules:
    - when: on_success

analyze:format:
  extends: .base_job
  stage: 🔍 analyze
  script:
    - echo "🎨 Checking code formatting"
    - dart format --output=none --set-exit-if-changed .
  rules:
    - when: on_success

analyze:security:
  extends: .base_job
  stage: 🔍 analyze
  script:
    - echo "🛡️ Running security analysis"
    - dart pub global activate pana
    - export PATH="$PATH:$PUB_CACHE/bin"
    - pana --json --output $REPORTS_DIR/security_analysis.json .
  artifacts:
    when: always
    paths:
      - $REPORTS_DIR/security_analysis.json
    expire_in: 7 days
  allow_failure: true
  rules:
    - when: on_success

# Test stage - Unit and integration tests with parallel execution
test:unit:
  extends: .base_job
  stage: 🧪 test
  parallel:
    matrix:
      - DART_VERSION: ["3.3.0", "stable", "beta"]
  image: dart:${DART_VERSION}
  script:
    - echo "🧪 Running unit tests with Dart ${DART_VERSION}"
    - dart test --concurrency=4 --reporter=json --file-reporter=json:$REPORTS_DIR/test_unit_${DART_VERSION}.json
    - echo "📊 Generating test coverage"
    - dart test --coverage=coverage
    - dart pub global activate coverage
    - export PATH="$PATH:$PUB_CACHE/bin"
    - format_coverage --lcov --in=coverage --out=coverage/lcov_${DART_VERSION}.info --packages=.dart_tool/package_config.json --report-on=lib
  coverage: '/Lines covered: \d+\.\d+%/'
  artifacts:
    when: always
    paths:
      - $REPORTS_DIR/test_unit_*.json
      - coverage/
    reports:
      junit: $REPORTS_DIR/test_unit_*.json
      coverage_report:
        coverage_format: cobertura
        path: coverage/lcov_*.info
    expire_in: 7 days
  rules:
    - when: on_success

test:integration:
  extends: .base_job
  stage: 🧪 test
  script:
    - echo "🔗 Running integration tests"
    - *install_tool
    - cd example/demo_app
    - dart pub get
    - cd ../..
    - bash test/e2e_workflow.sh
  artifacts:
    when: always
    paths:
      - $REPORTS_DIR/integration_*.json
      - example/demo_app/.dart_tool/flutter_keycheck/cache/
    expire_in: 7 days
  rules:
    - when: on_success

# Key validation stage - Core functionality testing
validate-keys:scan:
  extends: .base_job
  stage: 🔑 validate-keys
  script:
    - echo "🔑 Installing and testing key validation"
    - *install_tool
    - echo "📋 Running comprehensive key scans"
    - flutter_keycheck scan --scope workspace-only --output json > $REPORTS_DIR/scan_workspace.json
    - flutter_keycheck scan --scope deps-only --output json > $REPORTS_DIR/scan_deps.json
    - flutter_keycheck scan --scope all --output json > $REPORTS_DIR/scan_all.json
    - echo "✅ Validating scan results"
    - flutter_keycheck validate --fail-on-package-missing --fail-on-collision --output json > $REPORTS_DIR/validation.json
  artifacts:
    when: always
    paths:
      - $REPORTS_DIR/scan_*.json
      - $REPORTS_DIR/validation.json
      - .dart_tool/flutter_keycheck/cache/
    expire_in: 7 days
  rules:
    - when: on_success

validate-keys:baseline:
  extends: .base_job
  stage: 🔑 validate-keys
  script:
    - echo "📊 Testing baseline functionality"
    - *install_tool
    - flutter_keycheck baseline --input baseline.json --output $REPORTS_DIR/baseline_test.json
    - flutter_keycheck diff --baseline baseline.json --current $REPORTS_DIR/scan_all.json --output $REPORTS_DIR/diff_report.json
  dependencies:
    - validate-keys:scan
  artifacts:
    when: always
    paths:
      - $REPORTS_DIR/baseline_*.json
      - $REPORTS_DIR/diff_*.json
    expire_in: 7 days
  rules:
    - when: on_success

validate-keys:error-handling:
  extends: .base_job
  stage: 🔑 validate-keys
  script:
    - echo "🚨 Testing error handling and edge cases"
    - *install_tool
    - echo "Testing invalid config handling"
    - |
      set +e
      flutter_keycheck scan --scope workspace-only --config ./DOES_NOT_EXIST.json
      exit_code=$?
      echo "exit_code=$exit_code" | tee $REPORTS_DIR/error_handling.txt
      if [ "$exit_code" -ne 2 ]; then
        echo "ERROR: Expected exit code 2 for invalid config, got $exit_code"
        exit 1
      fi
      echo "✅ Invalid config correctly returns exit code 2"
      set -e
  artifacts:
    when: always
    paths:
      - $REPORTS_DIR/error_handling.txt
    expire_in: 7 days
  rules:
    - when: on_success

# Build stage - Compile executables and packages
build:executables:
  extends: .base_job
  stage: 🏗️ build
  parallel:
    matrix:
      - TARGET: ["linux-x64", "macos-x64", "windows-x64"]
  script:
    - echo "🏗️ Building executable for ${TARGET}"
    - mkdir -p $ARTIFACTS_DIR/executables
    - |
      case ${TARGET} in
        linux-x64)
          dart compile exe bin/flutter_keycheck.dart -o $ARTIFACTS_DIR/executables/flutter_keycheck_linux
          ;;
        macos-x64)
          dart compile exe bin/flutter_keycheck.dart -o $ARTIFACTS_DIR/executables/flutter_keycheck_macos
          ;;
        windows-x64)
          dart compile exe bin/flutter_keycheck.dart -o $ARTIFACTS_DIR/executables/flutter_keycheck_windows.exe
          ;;
      esac
    - ls -la $ARTIFACTS_DIR/executables/
  artifacts:
    when: on_success
    paths:
      - $ARTIFACTS_DIR/executables/
    expire_in: 30 days
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+.*$/'
    - if: '$CI_COMMIT_BRANCH == "main"'
    - when: manual

build:package:
  extends: .base_job
  stage: 🏗️ build
  script:
    - echo "📦 Preparing package for publication"
    - dart pub publish --dry-run > $REPORTS_DIR/pub_publish_dry_run.txt 2>&1
    - echo "✅ Package validation completed"
  artifacts:
    when: always
    paths:
      - $REPORTS_DIR/pub_publish_dry_run.txt
    expire_in: 7 days
  rules:
    - when: on_success

# Performance testing stage - Benchmarks and regression testing
performance:benchmark:
  extends: .base_job
  stage: ⚡ performance-test
  script:
    - echo "⚡ Running performance benchmarks"
    - *install_tool
    - *performance_setup
    - dart run tool/run_benchmark.dart --output json > performance/results/benchmark_${CI_COMMIT_SHA}.json
    - echo "📊 Analyzing performance metrics"
    - |
      if [ -f performance/baseline/benchmark_main.json ]; then
        echo "Comparing against baseline performance"
        # Performance regression check (simplified)
        python3 -c "
        import json, sys
        with open('performance/baseline/benchmark_main.json') as f: baseline = json.load(f)
        with open('performance/results/benchmark_${CI_COMMIT_SHA}.json') as f: current = json.load(f)
        
        # Check for 20% performance regression
        if current.get('scan_duration_ms', 0) > baseline.get('scan_duration_ms', 0) * 1.2:
            print('❌ Performance regression detected!')
            sys.exit(1)
        else:
            print('✅ Performance within acceptable bounds')
        " || echo "⚠️ Baseline comparison failed, continuing..."
      else
        echo "No baseline found, creating new baseline"
        cp performance/results/benchmark_${CI_COMMIT_SHA}.json performance/baseline/benchmark_main.json
      fi
  artifacts:
    when: always
    paths:
      - performance/
    expire_in: 30 days
  dependencies:
    - validate-keys:scan
  allow_failure: true
  rules:
    - when: on_success

performance:memory:
  extends: .base_job
  stage: ⚡ performance-test
  script:
    - echo "🧠 Memory usage analysis"
    - *install_tool
    - apt-get update && apt-get install -y time
    - echo "Testing memory consumption with large project"
    - /usr/bin/time -v flutter_keycheck scan --scope all 2>&1 | tee $REPORTS_DIR/memory_usage.txt
    - echo "📊 Extracting memory metrics"
    - grep "Maximum resident set size" $REPORTS_DIR/memory_usage.txt || echo "Memory metrics not available"
  artifacts:
    when: always
    paths:
      - $REPORTS_DIR/memory_usage.txt
    expire_in: 7 days
  allow_failure: true
  rules:
    - when: on_success

# Report stage - Generate comprehensive reports and MR comments
report:generate:
  extends: .base_job
  stage: 📊 report
  script:
    - echo "📊 Generating comprehensive validation report"
    - *install_tool
    - mkdir -p $REPORTS_DIR/final
    - |
      # Generate HTML report if data exists
      if [ -f "$REPORTS_DIR/validation.json" ]; then
        flutter_keycheck report --input $REPORTS_DIR/validation.json --format html --output $REPORTS_DIR/final/validation_report.html
        flutter_keycheck report --input $REPORTS_DIR/validation.json --format markdown --output $REPORTS_DIR/final/validation_report.md
      fi
    - echo "📋 Consolidating all reports"
    - |
      cat > $REPORTS_DIR/final/pipeline_summary.md << EOF
      # 🔑 Flutter KeyCheck CI/CD Pipeline Results
      
      **Commit**: \`${CI_COMMIT_SHA:0:8}\`  
      **Branch**: \`${CI_COMMIT_REF_NAME}\`  
      **Pipeline**: [#${CI_PIPELINE_ID}](${CI_PIPELINE_URL})
      
      ## 📊 Validation Summary
      EOF
      
      if [ -f "$REPORTS_DIR/validation.json" ]; then
        echo "✅ Key validation completed successfully" >> $REPORTS_DIR/final/pipeline_summary.md
      else
        echo "❌ Key validation failed or incomplete" >> $REPORTS_DIR/final/pipeline_summary.md
      fi
      
      echo "" >> $REPORTS_DIR/final/pipeline_summary.md
      echo "## 🧪 Test Results" >> $REPORTS_DIR/final/pipeline_summary.md
      
      if ls $REPORTS_DIR/test_unit_*.json 1> /dev/null 2>&1; then
        echo "✅ Unit tests completed" >> $REPORTS_DIR/final/pipeline_summary.md
      else
        echo "❌ Unit tests failed" >> $REPORTS_DIR/final/pipeline_summary.md
      fi
      
      echo "" >> $REPORTS_DIR/final/pipeline_summary.md
      echo "## ⚡ Performance Metrics" >> $REPORTS_DIR/final/pipeline_summary.md
      
      if [ -f "performance/results/benchmark_${CI_COMMIT_SHA}.json" ]; then
        echo "✅ Performance benchmarks completed" >> $REPORTS_DIR/final/pipeline_summary.md
      else
        echo "⚠️ Performance benchmarks not available" >> $REPORTS_DIR/final/pipeline_summary.md
      fi
  dependencies:
    - validate-keys:scan
    - validate-keys:baseline
    - test:unit
    - performance:benchmark
  artifacts:
    when: always
    paths:
      - $REPORTS_DIR/final/
    reports:
      junit: $REPORTS_DIR/test_unit_*.json
    expire_in: 30 days
  rules:
    - when: on_success

# MR comment generation for GitLab integration
report:mr-comment:
  extends: .base_job
  stage: 📊 report
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - echo "💬 Generating MR comment with results"
    - |
      if [ -n "$CI_MERGE_REQUEST_IID" ] && [ -f "$REPORTS_DIR/final/pipeline_summary.md" ]; then
        COMMENT_BODY=$(cat $REPORTS_DIR/final/pipeline_summary.md)
        
        # Post comment to GitLab MR using API
        curl --request POST \
          --header "PRIVATE-TOKEN: $GITLAB_ACCESS_TOKEN" \
          --header "Content-Type: application/json" \
          --data "{\"body\": \"$COMMENT_BODY\"}" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}/notes" \
          || echo "⚠️ Failed to post MR comment (token may not be available)"
      else
        echo "ℹ️ No MR context or report available for commenting"
      fi
  dependencies:
    - report:generate
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: on_success
  allow_failure: true

# Publication stage - Automated publishing for releases
publish:dry-run:
  extends: .base_job
  stage: 🚀 publish
  script:
    - echo "🚀 Validating package for publication"
    - |
      # Verify version matches tag
      if [[ "$CI_COMMIT_TAG" =~ ^v([0-9]+\.[0-9]+\.[0-9]+.*)$ ]]; then
        TAG_VERSION="${BASH_REMATCH[1]}"
        PUBSPEC_VERSION=$(grep '^version:' pubspec.yaml | sed 's/version: *//')
        
        if [ "$TAG_VERSION" != "$PUBSPEC_VERSION" ]; then
          echo "❌ ERROR: Tag version ($TAG_VERSION) does not match pubspec.yaml version ($PUBSPEC_VERSION)"
          exit 1
        fi
        echo "✅ Version $PUBSPEC_VERSION matches tag"
      fi
    - dart pub publish --dry-run
    - echo "✅ Package validation successful - ready for publication"
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+.*$/'
      when: on_success

publish:release:
  extends: .base_job
  stage: 🚀 publish
  script:
    - echo "🚀 Publishing package to pub.dev"
    - echo "⚠️ Manual intervention required for actual publication"
    - echo "To publish, run: dart pub publish --force"
    - echo "Current validation shows package is ready for publication"
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+.*$/'
      when: manual
      allow_failure: false
  environment:
    name: production
    action: start

# Container registry integration for custom runners (optional)
build:docker-runner:
  stage: 🏗️ build
  image: docker:24-dind
  services:
    - docker:24-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    IMAGE_TAG: $CI_REGISTRY_IMAGE/runner:$CI_COMMIT_REF_SLUG
  script:
    - echo "🐳 Building custom CI runner image"
    - |
      cat > Dockerfile.runner << EOF
      FROM dart:3.9.0-sdk
      
      # Install additional tools for CI
      RUN apt-get update && apt-get install -y \\
          git curl jq python3 python3-pip time \\
          && rm -rf /var/lib/apt/lists/*
      
      # Pre-install common pub packages
      RUN dart pub global activate pana
      RUN dart pub global activate coverage
      
      # Set up pub cache
      ENV PUB_CACHE=/opt/pub-cache
      RUN mkdir -p \$PUB_CACHE && chmod 777 \$PUB_CACHE
      
      WORKDIR /builds
      EOF
    - docker build -f Dockerfile.runner -t $IMAGE_TAG .
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker push $IMAGE_TAG
    - echo "🚀 Custom runner image available at: $IMAGE_TAG"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - .gitlab-ci.yml
      when: manual
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: on_success
  allow_failure: true